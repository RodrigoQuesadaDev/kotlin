/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.jps.incremental

import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.serialization.Flags
import org.jetbrains.kotlin.serialization.ProtoBuf
import org.jetbrains.kotlin.serialization.deserialization.NameResolver
import org.jetbrains.kotlin.serialization.deserialization.visibility
import org.jetbrains.kotlin.serialization.jvm.JvmProtoBufUtil
import java.util.EnumSet
import java.util.HashSet

public sealed class DifferenceKind() {
    public object NONE: DifferenceKind()
    public object CLASS_SIGNATURE: DifferenceKind()
    public class MEMBERS(val names: Collection<String>): DifferenceKind()
}

data class ProtoMapValue(val isPackageFacade: Boolean, val bytes: ByteArray)

public fun difference(oldData: ProtoMapValue, newData: ProtoMapValue): DifferenceKind {
    if (oldData.isPackageFacade != newData.isPackageFacade) return DifferenceKind.CLASS_SIGNATURE

    val differenceObject =
            if (oldData.isPackageFacade) DifferenceForPackageFacade(oldData, newData)  else DifferenceForClass(oldData, newData)

    return differenceObject.difference()
}

private abstract class Difference() {
    protected abstract val oldNameResolver: NameResolver
    protected abstract val newNameResolver: NameResolver

    protected val compareObject: ProtoCompareGenerated by lazy { ProtoCompareGenerated(oldNameResolver, newNameResolver) }

    fun difference(): DifferenceKind {
        firstCheck()?.let {
            return it
        }

        val names = calcNames()
        return if (names.isEmpty()) DifferenceKind.NONE else DifferenceKind.MEMBERS(names)
    }

    abstract protected fun firstCheck(): DifferenceKind?

    abstract protected fun calcNames(): Set<String>

    protected fun calcDifferenceForMembers(
            compareObject: ProtoCompareGenerated,
            oldList: List<ProtoBuf.Callable>,
            newList: List<ProtoBuf.Callable>
    ): Collection<String> {
        val result = hashSetOf<String>()

        val oldMap = oldList.groupBy { it.hashCode(compareObject.oldStringIndexes, compareObject.oldFqNameIndexes) }
        val newMap = newList.groupBy { it.hashCode(compareObject.newStringIndexes, compareObject.newFqNameIndexes) }

        val oldHashes = oldMap.keySet()
        val newHashes = newMap.keySet()

        val oldOnlyHashes = oldHashes - newHashes
        val newOnlyHashes = newHashes - oldHashes

        oldOnlyHashes.forEach { hash ->
            oldMap[hash]!!.forEach {
                result.add(compareObject.oldNameResolver.getString(it.name))
            }
        }

        newOnlyHashes.forEach { hash ->
            newMap[hash]!!.forEach {
                result.add(compareObject.newNameResolver.getString(it.name))
            }
        }

        val commonHashes = HashSet<Int>(oldHashes)
        commonHashes.retainAll(newHashes)

        commonHashes.forEach { commonHash ->
            val oldMembers = oldMap[commonHash]!!
            val newMembers = newMap[commonHash]!!
            result.addAll(calcDifferenceForEqualHashes(compareObject, oldMembers, newMembers))
        }

        return result
    }

    private fun calcDifferenceForEqualHashes(
            compareObject: ProtoCompareGenerated,
            oldList: List<ProtoBuf.Callable>,
            newList: List<ProtoBuf.Callable>
    ): Collection<String> {
        val result = hashSetOf<String>()
        val newSet = HashSet(newList)

        oldList.forEach { oldMember ->
            val newMember = newSet.firstOrNull { compareObject.checkEquals(oldMember, it) }
            if (newMember != null) {
                newSet.remove(newMember)
            }
            else {
                result.add(compareObject.oldNameResolver.getString(oldMember.name))
            }
        }

        newSet.forEach { newMember ->
            result.add(compareObject.newNameResolver.getString(newMember.name))
        }

        return result
    }

    protected fun calcDifferenceForNames(
            compareObject: ProtoCompareGenerated,
            oldList: List<Int>,
            newList: List<Int>
    ): Collection<String> {
        val oldNames = oldList.map { compareObject.oldNameResolver.getString(it) }.toSet()
        val newNames = newList.map { compareObject.newNameResolver.getString(it) }.toSet()
        return symmetricDifference(oldNames, newNames)
    }

    private fun <E> symmetricDifference(old: Set<E>, new: Set<E>): Set<E> {
        val intersection = HashSet<E>(old)
        intersection.retainAll(new)
        val result = HashSet<E>(old)
        result.addAll(new)
        result.removeAll(intersection)
        return result
    }
}

private class DifferenceForClass(oldData: ProtoMapValue, newData: ProtoMapValue) : Difference() {
    private val CONSTRUCTOR = "<init>"

    private val CLASS_SIGNATURE_ENUMS = EnumSet.of(
            ProtoCompareGenerated.ProtoBufClassKind.FLAGS,
            ProtoCompareGenerated.ProtoBufClassKind.FQ_NAME,
            ProtoCompareGenerated.ProtoBufClassKind.TYPE_PARAMETER_LIST,
            ProtoCompareGenerated.ProtoBufClassKind.SUPERTYPE_LIST,
            ProtoCompareGenerated.ProtoBufClassKind.CLASS_ANNOTATION_LIST
    )

    val oldClassData = JvmProtoBufUtil.readClassDataFrom(oldData.bytes)
    val newClassData = JvmProtoBufUtil.readClassDataFrom(newData.bytes)

    val oldProto = oldClassData.classProto
    val newProto = newClassData.classProto

    override val oldNameResolver = oldClassData.nameResolver
    override val newNameResolver = newClassData.nameResolver

    val diff = compareObject.difference(oldProto, newProto)

    override fun firstCheck(): DifferenceKind? {
        if (diff.isEmpty()) return DifferenceKind.NONE

        CLASS_SIGNATURE_ENUMS.forEach { if (it in diff) return DifferenceKind.CLASS_SIGNATURE }

        return null
    }

    override fun calcNames(): Set<String> {
        val names = hashSetOf<String>()

        fun Int.oldToNames() = names.add(oldNameResolver.getString(this))
        fun Int.newToNames() = names.add(newNameResolver.getString(this))

        for (kind in diff) {
            when (kind!!) {
                ProtoCompareGenerated.ProtoBufClassKind.COMPANION_OBJECT_NAME -> {
                    if (oldProto.hasCompanionObjectName()) oldProto.companionObjectName.oldToNames()
                    if (newProto.hasCompanionObjectName()) newProto.companionObjectName.newToNames()
                }
                ProtoCompareGenerated.ProtoBufClassKind.NESTED_CLASS_NAME_LIST ->
                    names.addAll(calcDifferenceForNames(compareObject, oldProto.nestedClassNameList, newProto.nestedClassNameList))
                ProtoCompareGenerated.ProtoBufClassKind.MEMBER_LIST -> {
                    val oldMembers = oldProto.memberList.filter { !it.isPrivate() }
                    val newMembers = newProto.memberList.filter { !it.isPrivate() }
                    names.addAll(calcDifferenceForMembers(compareObject, oldMembers, newMembers))
                }
                ProtoCompareGenerated.ProtoBufClassKind.ENUM_ENTRY_LIST ->
                    names.addAll(calcDifferenceForNames(compareObject, oldProto.enumEntryList, newProto.enumEntryList))
                ProtoCompareGenerated.ProtoBufClassKind.PRIMARY_CONSTRUCTOR ->
                    if (isNonPrivatePrimaryConstructorsDiffer()) {
                        names.add(CONSTRUCTOR)
                    }
                ProtoCompareGenerated.ProtoBufClassKind.SECONDARY_CONSTRUCTOR_LIST ->
                    if (isNonPrivateSecondaryConstructorsDiffer()) {
                        names.add(CONSTRUCTOR)
                    }
                ProtoCompareGenerated.ProtoBufClassKind.FLAGS,
                ProtoCompareGenerated.ProtoBufClassKind.FQ_NAME,
                ProtoCompareGenerated.ProtoBufClassKind.TYPE_PARAMETER_LIST,
                ProtoCompareGenerated.ProtoBufClassKind.SUPERTYPE_LIST,
                ProtoCompareGenerated.ProtoBufClassKind.CLASS_ANNOTATION_LIST ->
                    throw IllegalArgumentException("Unexpected kind: $kind")
            }
        }
        return names
    }

    private fun isNonPrivatePrimaryConstructorsDiffer(): Boolean {
        val oldPrimaryConstructor = oldProto.getNonPrivatePrimaryConstructor()
        val newPrimaryConstructor = newProto.getNonPrivatePrimaryConstructor()
        return ((oldPrimaryConstructor == null || newPrimaryConstructor == null || !compareObject.checkEquals(oldPrimaryConstructor, newPrimaryConstructor)) &&
            (oldPrimaryConstructor != null || newPrimaryConstructor != null))
    }

    private fun isNonPrivateSecondaryConstructorsDiffer(): Boolean {
        val oldSecondaryConstructors = oldProto.secondaryConstructorList.filter { !it.isPrivate() }
        val newSecondaryConstructors = newProto.secondaryConstructorList.filter { !it.isPrivate() }
        return (oldSecondaryConstructors.size() != newSecondaryConstructors.size() ||
            oldSecondaryConstructors.indices.any { !compareObject.checkEquals(oldSecondaryConstructors[it], newSecondaryConstructors[it]) })
    }

    private fun ProtoBuf.Class.getNonPrivatePrimaryConstructor(): ProtoBuf.Class.PrimaryConstructor? {
        if (!hasPrimaryConstructor()) return null

        return if (primaryConstructor?.data?.isPrivate() ?: false) null else primaryConstructor
    }

    private fun ProtoBuf.Callable.isPrivate(): Boolean = Visibilities.isPrivate(visibility(Flags.VISIBILITY.get(flags)))
}

private class DifferenceForPackageFacade(oldData: ProtoMapValue, newData: ProtoMapValue) : Difference() {
    val oldPackageData = JvmProtoBufUtil.readPackageDataFrom(oldData.bytes)
    val newPackageData = JvmProtoBufUtil.readPackageDataFrom(newData.bytes)

    val oldProto = oldPackageData.packageProto
    val newProto = newPackageData.packageProto

    override val oldNameResolver = oldPackageData.nameResolver
    override val newNameResolver = newPackageData.nameResolver

    val diff = compareObject.difference(oldProto, newProto)

    override fun firstCheck(): DifferenceKind? = if (diff.isEmpty()) DifferenceKind.NONE else null

    override fun calcNames(): Set<String> {
        val names = hashSetOf<String>()

        for (kind in diff) {
            when (kind!!) {
                ProtoCompareGenerated.ProtoBufPackageKind.MEMBER_LIST ->
                    names.addAll(calcDifferenceForMembers(compareObject, oldProto.memberList, newProto.memberList))
            }
        }
        return names
    }
}
